import Payment from "../models/payment.model.js";
import Order from "../models/orders.model.js";
import crypto from "crypto";
import querystring from "querystring";
import moment from "moment-timezone";
import axios from "axios";

export class PaymentService {
  // VNPay configuration t·ª´ .env
  static VNP_TMN_CODE = process.env.VNP_TMNCODE;
  static VNP_HASH_SECRET = process.env.VNP_HASHSECRET;
  static VNP_URL = process.env.VNP_URL || 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html';
  static VNP_RETURN_URL = process.env.VNP_RETURNURL || 'http://localhost:6789/api/v1/payment/vnpay_return';

  // T·∫°o payment cho order
  static async createPayment(orderId, method, customerInfo = {}, ipAddress = '') {
    const order = await Order.findById(orderId);
    if (!order) {
      throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
    }

    if (order.payment_status === 'completed') {
      throw new Error('ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n');
    }

    // T·∫°o payment record
    const payment = new Payment({
      order_id: orderId,
      amount: order.total,
      method,
      customer_info: {
        name: customerInfo.name || order.shipping_address?.name,
        email: customerInfo.email || order.shipping_address?.email,
        phone: customerInfo.phone || order.shipping_address?.phone
      },
      ip_address: ipAddress,
      status: 'pending'
    });

    const savedPayment = await payment.save();

    let paymentUrl = null;
    let additionalData = {};

    // Generate payment URL based on method
    switch (method.toLowerCase()) {
      case 'vnpay':
        paymentUrl = await this.createVNPayUrl(savedPayment, order);
        break;
      case 'cod':
        // COD kh√¥ng c·∫ßn payment URL
        paymentUrl = null;
        break;
      default:
        throw new Error('Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
    }

    return {
      payment: savedPayment,
      paymentUrl,
      ...additionalData
    };
  }

  // T·∫°o VNPay URL
  static async createVNPayUrl(payment, order) {
    console.log('üîß Checking VNPay Config...');
    console.log('VNP_TMN_CODE:', this.VNP_TMN_CODE);
    console.log('VNP_HASH_SECRET exists:', !!this.VNP_HASH_SECRET);
    console.log('VNP_URL:', this.VNP_URL);
    console.log('VNP_RETURN_URL:', this.VNP_RETURN_URL);
    
    if (!this.VNP_TMN_CODE || !this.VNP_HASH_SECRET) {
      console.error('‚ùå VNPay config missing!');
      throw new Error('VNPay ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·∫ßy ƒë·ªß');
    }

    console.log('üîß VNPay Config:', {
      tmnCode: this.VNP_TMN_CODE,
      hasSecret: !!this.VNP_HASH_SECRET,
      url: this.VNP_URL,
      returnUrl: this.VNP_RETURN_URL
    });

    // T·∫°o th·ªùi gian theo ƒë·ªãnh d·∫°ng VNPay y√™u c·∫ßu: yyyyMMddHHmmss
    const createDate = moment().tz('Asia/Ho_Chi_Minh').format('YYYYMMDDHHmmss');

    // T·∫°o expire date (15 ph√∫t sau)
    const expireTime = new Date(Date.now() + 15 * 60 * 1000);
    const expireDate = moment(expireTime).tz('Asia/Ho_Chi_Minh').format('YYYYMMDDHHmmss');

    const txnRef = payment._id.toString();

    // T·∫°o parameters theo ƒë√∫ng format VNPay
    const vnpParams = {
      vnp_Version: '2.1.0',
      vnp_Command: 'pay',
      vnp_TmnCode: this.VNP_TMN_CODE,
      vnp_Amount: Math.round(payment.amount * 100), // VNPay y√™u c·∫ßu amount * 100 (ƒë∆°n v·ªã: xu)
      vnp_CurrCode: 'VND',
      vnp_TxnRef: txnRef,
      vnp_OrderInfo: `Thanh toan don hang #${order._id.toString().slice(-8)}`,
      vnp_OrderType: 'other',
      vnp_Locale: 'vn',
      vnp_ReturnUrl: this.VNP_RETURN_URL,
      vnp_IpAddr: payment.ip_address || '127.0.0.1',
      vnp_CreateDate: createDate,
      vnp_ExpireDate: expireDate
    };

    console.log('üìã VNPay Params Before Sort:', vnpParams);

    // S·∫Øp x·∫øp parameters theo alphabet (VNPay y√™u c·∫ßu)
    const sortedParams = this.sortObject(vnpParams);
    console.log('üìã Sorted Params:', sortedParams);
    
    // T·∫°o query string ƒë·ªÉ k√Ω (VNPay format - kh√¥ng encode cho signature)
    const signData = Object.keys(sortedParams)
      .map(key => `${key}=${sortedParams[key]}`)
      .join('&');
    console.log('üìù Sign Data:', signData);
    
    // T·∫°o ch·ªØ k√Ω HMAC SHA512
    const hmac = crypto.createHmac('sha512', this.VNP_HASH_SECRET);
    const signed = hmac.update(signData, 'utf8').digest('hex');
    console.log('üîê Signature:', signed);
    
    // Th√™m ch·ªØ k√Ω v√†o params
    sortedParams.vnp_SecureHash = signed;

    // T·∫°o URL cu·ªëi c√πng (encode cho URL)
    const finalQueryString = Object.keys(sortedParams)
      .map(key => `${key}=${encodeURIComponent(sortedParams[key])}`)
      .join('&');
    const paymentUrl = this.VNP_URL + '?' + finalQueryString;
    console.log('üîó Final VNPay URL:', paymentUrl);

    // L∆∞u th√¥ng tin thanh to√°n v√†o ƒë∆°n h√†ng (t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈©)
    order.payment_info = {
      ...order.payment_info,
      vnpay_txn_ref: txnRef,
      vnpay_create_date: createDate,
      payment_url: paymentUrl,
    };
    await order.save();

    return paymentUrl;
  }

  // Verify VNPay return
  static async verifyVNPayReturn(vnpParams) {
    console.log('üîç Verifying VNPay Return:', vnpParams);

    if (!vnpParams.vnp_SecureHash) {
      throw new Error('Thi·∫øu ch·ªØ k√Ω b·∫£o m·∫≠t');
    }

    const secureHash = vnpParams.vnp_SecureHash;
    
    // T·∫°o b·∫£n sao ƒë·ªÉ x·ª≠ l√Ω
    const paramsToVerify = { ...vnpParams };
    delete paramsToVerify.vnp_SecureHash;
    delete paramsToVerify.vnp_SecureHashType;

    // S·∫Øp x·∫øp parameters
    const sortedParams = this.sortObject(paramsToVerify);
    const signData = Object.keys(sortedParams)
      .map(key => `${key}=${sortedParams[key]}`)
      .join('&');
    
    console.log('üìù Verify Sign Data:', signData);

    // T·∫°o ch·ªØ k√Ω ƒë·ªÉ so s√°nh
    const hmac = crypto.createHmac('sha512', this.VNP_HASH_SECRET);
    const signed = hmac.update(signData, 'utf8').digest('hex');
    
    console.log('üîê Expected Signature:', signed);
    console.log('üîê Received Signature:', secureHash);
    console.log('‚úÖ Signature Match:', secureHash === signed);

    if (secureHash === signed) {
      // T√¨m payment record
      const payment = await Payment.findById(vnpParams.vnp_TxnRef);
      if (!payment) {
        throw new Error('Kh√¥ng t√¨m th·∫•y giao d·ªãch thanh to√°n');
      }

      console.log('üí≥ Found Payment:', payment._id);
      console.log('üè¶ VNPay Response Code:', vnpParams.vnp_ResponseCode);

      // X√°c ƒë·ªãnh tr·∫°ng th√°i thanh to√°n
      let status = 'failed';
      let failureReason = null;

      switch (vnpParams.vnp_ResponseCode) {
        case '00':
          status = 'completed';
          break;
        case '07':
          status = 'failed';
          failureReason = 'Tr·ª´ ti·ªÅn th√†nh c√¥ng. Giao d·ªãch b·ªã nghi ng·ªù (li√™n quan t·ªõi l·ª´a ƒë·∫£o, giao d·ªãch b·∫•t th∆∞·ªùng).';
          break;
        case '09':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng ch∆∞a ƒëƒÉng k√Ω d·ªãch v·ª• InternetBanking t·∫°i ng√¢n h√†ng.';
          break;
        case '10':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng x√°c th·ª±c th√¥ng tin th·∫ª/t√†i kho·∫£n kh√¥ng ƒë√∫ng qu√° 3 l·∫ßn';
          break;
        case '11':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: ƒê√£ h·∫øt h·∫°n ch·ªù thanh to√°n. Xin qu√Ω kh√°ch vui l√≤ng th·ª±c hi·ªán l·∫°i giao d·ªãch.';
          break;
        case '12':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng b·ªã kh√≥a.';
          break;
        case '13':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Qu√Ω kh√°ch nh·∫≠p sai m·∫≠t kh·∫©u x√°c th·ª±c giao d·ªãch (OTP).';
          break;
        case '24':
          status = 'cancelled';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng h·ªßy giao d·ªãch';
          break;
        case '51':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa qu√Ω kh√°ch kh√¥ng ƒë·ªß s·ªë d∆∞ ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.';
          break;
        case '65':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa Qu√Ω kh√°ch ƒë√£ v∆∞·ª£t qu√° h·∫°n m·ª©c giao d·ªãch trong ng√†y.';
          break;
        case '75':
          status = 'failed';
          failureReason = 'Ng√¢n h√†ng thanh to√°n ƒëang b·∫£o tr√¨.';
          break;
        case '79':
          status = 'failed';
          failureReason = 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: KH nh·∫≠p sai m·∫≠t kh·∫©u thanh to√°n qu√° s·ªë l·∫ßn quy ƒë·ªãnh.';
          break;
        default:
          status = 'failed';
          failureReason = `Giao d·ªãch th·∫•t b·∫°i v·ªõi m√£ l·ªói: ${vnpParams.vnp_ResponseCode}`;
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
      const updatedPayment = await this.updatePaymentStatus(payment._id, status, {
        gateway_transaction_id: vnpParams.vnp_TransactionNo,
        gateway_response: vnpParams,
        failure_reason: failureReason
      });

      // C·∫≠p nh·∫≠t th√¥ng tin thanh to√°n v√†o order (t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈©)
      const order = await Order.findById(payment.order_id);
      if (order) {
        order.payment_info = {
          ...order.payment_info,
          vnpay_response_code: vnpParams.vnp_ResponseCode,
          vnpay_transaction_no: vnpParams.vnp_TransactionNo,
          vnpay_bank_code: vnpParams.vnp_BankCode,
          vnpay_pay_date: vnpParams.vnp_PayDate,
          vnpay_amount: parseInt(vnpParams.vnp_Amount) / 100,
        };

        // T·ª± ƒë·ªông chuy·ªÉn tr·∫°ng th√°i ƒë∆°n h√†ng n·∫øu thanh to√°n th√†nh c√¥ng
        if (status === 'completed' && order.status === 'pending') {
          order.status = 'confirmed';
          order.confirmed_at = new Date();
        }

        await order.save();
      }

      console.log('‚úÖ Payment Updated:', {
        id: updatedPayment._id,
        status: updatedPayment.status,
        amount: updatedPayment.amount
      });

      return updatedPayment;
    }
    
    throw new Error('Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá ho·∫∑c d·ªØ li·ªáu ƒë√£ b·ªã thay ƒë·ªïi');
  }

  // Verify MoMo IPN
  static async verifyMoMoIPN(momoData) {
    const {
      partnerCode,
      orderId,
      requestId,
      amount,
      orderInfo,
      orderType,
      transId,
      resultCode,
      message,
      payType,
      responseTime,
      extraData,
      signature
    } = momoData;

    const rawSignature = `accessKey=${this.MOMO_ACCESS_KEY}&amount=${amount}&extraData=${extraData}&message=${message}&orderId=${orderId}&orderInfo=${orderInfo}&orderType=${orderType}&partnerCode=${partnerCode}&payType=${payType}&requestId=${requestId}&responseTime=${responseTime}&resultCode=${resultCode}&transId=${transId}`;
    
    const expectedSignature = crypto
      .createHmac('sha256', this.MOMO_SECRET_KEY)
      .update(rawSignature)
      .digest('hex');

    if (signature === expectedSignature) {
      const payment = await Payment.findById(orderId);
      if (payment) {
        const status = resultCode === 0 ? 'completed' : 'failed';
        return await this.updatePaymentStatus(payment._id, status, {
          gateway_transaction_id: transId,
          gateway_response: momoData
        });
      }
    }

    throw new Error('Ch·ªØ k√Ω MoMo kh√¥ng h·ª£p l·ªá');
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
  static async updatePaymentStatus(paymentId, status, gatewayData = {}) {
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error('Kh√¥ng t√¨m th·∫•y payment');
    }

    payment.status = status;
    payment.gateway_transaction_id = gatewayData.gateway_transaction_id;
    payment.gateway_response = gatewayData.gateway_response;
    
    if (status === 'completed') {
      payment.paid_at = new Date();
    } else if (status === 'failed') {
      payment.failed_at = new Date();
      payment.failure_reason = gatewayData.failure_reason || 'Payment failed';
    }

    const updatedPayment = await payment.save();

    // C·∫≠p nh·∫≠t order status
    await Order.findByIdAndUpdate(payment.order_id, {
      payment_status: status === 'completed' ? 'completed' : 'failed',
      paid_at: status === 'completed' ? new Date() : undefined
    });

    return updatedPayment;
  }

  // L·∫•y payment theo ID
  static async getPaymentById(paymentId) {
    const payment = await Payment.findById(paymentId).populate('order_id');
    if (!payment) {
      throw new Error('Kh√¥ng t√¨m th·∫•y payment');
    }
    return payment;
  }

  // L·∫•y payments c·ªßa user
  static async getUserPayments(userId, page = 1, limit = 10) {
    const skip = (page - 1) * limit;
    
    const [payments, total] = await Promise.all([
      Payment.find()
        .populate({
          path: 'order_id',
          match: { user_id: userId },
          populate: { path: 'user_id', select: 'name email' }
        })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Payment.countDocuments()
    ]);

    // Filter out payments where order is null (not belonging to user)
    const userPayments = payments.filter(payment => payment.order_id);

    return {
      payments: userPayments,
      total: userPayments.length,
      page,
      totalPages: Math.ceil(userPayments.length / limit)
    };
  }

  // Helper function to sort object
  static sortObject(obj) {
    const sorted = {};
    const keys = Object.keys(obj).sort();
    keys.forEach(key => {
      if (obj[key] !== null && obj[key] !== undefined && obj[key] !== '') {
        sorted[key] = obj[key];
      }
    });
    return sorted;
  }

  // L·∫•y th√¥ng b√°o l·ªói t·ª´ VNPay response code
  static getVNPayResponseMessage(responseCode) {
    const messages = {
      '00': 'Giao d·ªãch th√†nh c√¥ng',
      '07': 'Tr·ª´ ti·ªÅn th√†nh c√¥ng. Giao d·ªãch b·ªã nghi ng·ªù (li√™n quan t·ªõi l·ª´a ƒë·∫£o, giao d·ªãch b·∫•t th∆∞·ªùng).',
      '09': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng ch∆∞a ƒëƒÉng k√Ω d·ªãch v·ª• InternetBanking t·∫°i ng√¢n h√†ng.',
      '10': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng x√°c th·ª±c th√¥ng tin th·∫ª/t√†i kho·∫£n kh√¥ng ƒë√∫ng qu√° 3 l·∫ßn',
      '11': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: ƒê√£ h·∫øt h·∫°n ch·ªù thanh to√°n. Xin qu√Ω kh√°ch vui l√≤ng th·ª±c hi·ªán l·∫°i giao d·ªãch.',
      '12': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng b·ªã kh√≥a.',
      '13': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do Qu√Ω kh√°ch nh·∫≠p sai m·∫≠t kh·∫©u x√°c th·ª±c giao d·ªãch (OTP).',
      '24': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng h·ªßy giao d·ªãch',
      '51': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa qu√Ω kh√°ch kh√¥ng ƒë·ªß s·ªë d∆∞ ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.',
      '65': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa Qu√Ω kh√°ch ƒë√£ v∆∞·ª£t qu√° h·∫°n m·ª©c giao d·ªãch trong ng√†y.',
      '75': 'Ng√¢n h√†ng thanh to√°n ƒëang b·∫£o tr√¨.',
      '79': 'Giao d·ªãch kh√¥ng th√†nh c√¥ng do: KH nh·∫≠p sai m·∫≠t kh·∫©u thanh to√°n qu√° s·ªë l·∫ßn quy ƒë·ªãnh.',
      '99': 'C√°c l·ªói kh√°c (l·ªói c√≤n l·∫°i, kh√¥ng c√≥ trong danh s√°ch m√£ l·ªói ƒë√£ li·ªát k√™)',
    };

    return messages[responseCode] || 'L·ªói kh√¥ng x√°c ƒë·ªãnh';
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - t·∫°o payment URL
  static async createPaymentUrl({ orderId, bankCode, ipAddr }) {
    try {
      console.log('üîç Creating payment URL for:', { orderId, bankCode, ipAddr });
      
      const order = await Order.findById(orderId);
      if (!order) {
        console.error('‚ùå Order not found:', orderId);
        throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
      }

      console.log('üìã Found order:', {
        id: order._id,
        total: order.total,
        payment_status: order.payment_status
      });

      if (order.payment_status === 'completed') {
        throw new Error('ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n');
      }

      // T·∫°o payment record
      const payment = new Payment({
        order_id: orderId,
        amount: order.total,
        method: 'vnpay',
        customer_info: {
          name: order.shipping_address?.name,
          email: order.shipping_address?.email,
          phone: order.shipping_address?.phone
        },
        ip_address: ipAddr || '127.0.0.1',
        status: 'pending'
      });

      console.log('üí≥ Creating payment record:', {
        order_id: payment.order_id,
        amount: payment.amount,
        method: payment.method
      });

      const savedPayment = await payment.save();
      console.log('‚úÖ Payment saved:', savedPayment._id);
      
      const paymentUrl = await this.createVNPayUrl(savedPayment, order);
      console.log('üîó VNPay URL created successfully');

      return {
        success: true,
        paymentUrl,
        txnRef: savedPayment._id.toString(),
        payment: savedPayment
      };
    } catch (error) {
      console.error('‚ùå createPaymentUrl error:', error);
      throw error;
    }
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - x·ª≠ l√Ω callback
  static async handleCallback(vnpParams) {
    try {
      const updatedPayment = await this.verifyVNPayReturn(vnpParams);
      
      return {
        success: updatedPayment.status === 'completed',
        message: updatedPayment.status === 'completed' 
          ? 'Thanh to√°n th√†nh c√¥ng' 
          : this.getVNPayResponseMessage(vnpParams.vnp_ResponseCode),
        orderId: updatedPayment.order_id,
        transactionNo: vnpParams.vnp_TransactionNo,
        amount: updatedPayment.amount,
        responseCode: vnpParams.vnp_ResponseCode
      };
    } catch (error) {
      console.error('VNPay callback error:', error);
      throw error;
    }
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - ki·ªÉm tra tr·∫°ng th√°i
  static async checkPaymentStatus(orderId) {
    try {
      const order = await Order.findById(orderId);
      if (!order) {
        throw new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng');
      }

      return {
        orderId: order._id,
        payment_status: order.payment_status,
        payment_info: order.payment_info,
        total: order.total,
      };
    } catch (error) {
      console.error('Check payment status error:', error);
      throw error;
    }
  }

  // T·∫°o IPN URL handler cho VNPay (webhook)
  static async handleVNPayIPN(vnpParams) {
    console.log('üì® VNPay IPN Received:', vnpParams);

    try {
      // Verify signature
      if (!vnpParams.vnp_SecureHash) {
        return { RspCode: '97', Message: 'Invalid signature' };
      }

      const secureHash = vnpParams.vnp_SecureHash;
      const paramsToVerify = { ...vnpParams };
      delete paramsToVerify.vnp_SecureHash;
      delete paramsToVerify.vnp_SecureHashType;

      const sortedParams = this.sortObject(paramsToVerify);
      const signData = Object.keys(sortedParams)
        .map(key => `${key}=${sortedParams[key]}`)
        .join('&');
      const hmac = crypto.createHmac('sha512', this.VNP_HASH_SECRET);
      const signed = hmac.update(signData, 'utf8').digest('hex');

      if (secureHash !== signed) {
        return { RspCode: '97', Message: 'Invalid signature' };
      }

      // Ki·ªÉm tra payment t·ªìn t·∫°i
      const payment = await Payment.findById(vnpParams.vnp_TxnRef);
      if (!payment) {
        return { RspCode: '01', Message: 'Order not found' };
      }

      // Ki·ªÉm tra s·ªë ti·ªÅn
      const vnpAmount = parseInt(vnpParams.vnp_Amount) / 100;
      if (Math.abs(vnpAmount - payment.amount) > 0.01) {
        return { RspCode: '04', Message: 'Invalid amount' };
      }

      // Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i
      if (payment.status === 'completed') {
        return { RspCode: '02', Message: 'Order already confirmed' };
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
      if (vnpParams.vnp_ResponseCode === '00') {
        await this.updatePaymentStatus(payment._id, 'completed', {
          gateway_transaction_id: vnpParams.vnp_TransactionNo,
          gateway_response: vnpParams
        });
        
        console.log('‚úÖ VNPay IPN: Payment completed successfully');
        return { RspCode: '00', Message: 'Success' };
      } else {
        await this.updatePaymentStatus(payment._id, 'failed', {
          gateway_transaction_id: vnpParams.vnp_TransactionNo,
          gateway_response: vnpParams,
          failure_reason: `VNPay error code: ${vnpParams.vnp_ResponseCode}`
        });
        
        console.log('‚ùå VNPay IPN: Payment failed');
        return { RspCode: '00', Message: 'Success' };
      }

    } catch (error) {
      console.error('‚ùå VNPay IPN Error:', error);
      return { RspCode: '99', Message: 'Unknown error' };
    }
  }

  // Refund payment (for admin)
  static async refundPayment(paymentId, refundAmount, reason) {
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error('Kh√¥ng t√¨m th·∫•y payment');
    }

    if (payment.status !== 'completed') {
      throw new Error('Ch·ªâ c√≥ th·ªÉ ho√†n ti·ªÅn cho payment ƒë√£ ho√†n th√†nh');
    }

    if (refundAmount > payment.amount) {
      throw new Error('S·ªë ti·ªÅn ho√†n kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n s·ªë ti·ªÅn g·ªëc');
    }

    // Create refund record
    payment.refunds = payment.refunds || [];
    payment.refunds.push({
      amount: refundAmount,
      reason,
      refunded_at: new Date(),
      status: 'pending'
    });

    payment.refund_amount = (payment.refund_amount || 0) + refundAmount;
    
    if (payment.refund_amount >= payment.amount) {
      payment.status = 'refunded';
    } else {
      payment.status = 'partially_refunded';
    }

    return await payment.save();
  }

  // ============= ADMIN METHODS =============

  // L·∫•y t·∫•t c·∫£ payments v·ªõi filter cho admin
  static async getAllPayments(options = {}) {
    const {
      page = 1,
      limit = 10,
      status = "",
      method = "",
      startDate = "",
      endDate = "",
      sortBy = "createdAt",
      sortOrder = "desc"
    } = options;

    // X√¢y d·ª±ng query
    const query = {};
    
    if (status && status.trim() !== "") {
      query.status = status;
    }
    
    if (method && method.trim() !== "") {
      query.method = method;
    }

    if (startDate && endDate) {
      query.createdAt = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    } else if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    } else if (endDate) {
      query.createdAt = { $lte: new Date(endDate) };
    }

    // S·∫Øp x·∫øp
    const sort = {};
    sort[sortBy] = sortOrder === "desc" ? -1 : 1;

    const skip = (page - 1) * limit;

    const [payments, total] = await Promise.all([
      Payment.find(query)
        .populate({
          path: 'orderId',
          select: 'orderNumber totalAmount userId',
          populate: {
            path: 'userId',
            select: 'name email phone_number'
          }
        })
        .sort(sort)
        .skip(skip)
        .limit(limit),
      Payment.countDocuments(query)
    ]);

    return {
      payments,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    };
  }

  // L·∫•y payment theo ID
  static async getPaymentById(paymentId) {
    const payment = await Payment.findById(paymentId)
      .populate({
        path: 'orderId',
        select: 'orderNumber totalAmount userId items shippingAddress',
        populate: {
          path: 'userId',
          select: 'name email phone_number'
        }
      });
    
    if (!payment) {
      throw new Error('Kh√¥ng t√¨m th·∫•y payment');
    }
    
    return payment;
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment (cho COD, bank transfer manual)
  static async updatePaymentStatus(paymentId, updateData) {
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error('Kh√¥ng t√¨m th·∫•y payment');
    }

    // Kh√¥ng cho ph√©p thay ƒë·ªïi tr·∫°ng th√°i c·ªßa payment gateway t·ª± ƒë·ªông
    if (['vnpay'].includes(payment.method) && 
        payment.status === 'success') {
      throw new Error('Kh√¥ng th·ªÉ thay ƒë·ªïi tr·∫°ng th√°i payment ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω t·ª± ƒë·ªông');
    }

    const updatedPayment = await Payment.findByIdAndUpdate(
      paymentId,
      {
        status: updateData.status,
        adminNote: updateData.adminNote,
        updatedAt: new Date()
      },
      { new: true, runValidators: true }
    ).populate({
      path: 'orderId',
      select: 'orderNumber totalAmount userId',
      populate: {
        path: 'userId',
        select: 'name email'
      }
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i order t∆∞∆°ng ·ª©ng n·∫øu c·∫ßn
    if (updateData.status === 'success') {
      await Order.findByIdAndUpdate(payment.orderId, {
        payment_status: 'completed',
        payment_method: payment.method
      });
    } else if (updateData.status === 'failed' || updateData.status === 'cancelled') {
      await Order.findByIdAndUpdate(payment.orderId, {
        payment_status: 'failed'
      });
    }

    return updatedPayment;
  }

  // Th·ªëng k√™ payment
  static async getPaymentStats(startDate, endDate) {
    const matchCondition = {};
    
    if (startDate && endDate) {
      matchCondition.createdAt = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }

    const [
      totalStats,
      methodStats,
      statusStats,
      dailyStats
    ] = await Promise.all([
      // T·ªïng quan
      Payment.aggregate([
        { $match: matchCondition },
        {
          $group: {
            _id: null,
            totalAmount: { $sum: "$amount" },
            totalPayments: { $sum: 1 },
            avgAmount: { $avg: "$amount" }
          }
        }
      ]),

      // Th·ªëng k√™ theo ph∆∞∆°ng th·ª©c
      Payment.aggregate([
        { $match: matchCondition },
        {
          $group: {
            _id: "$method",
            count: { $sum: 1 },
            totalAmount: { $sum: "$amount" }
          }
        },
        { $sort: { count: -1 } }
      ]),

      // Th·ªëng k√™ theo tr·∫°ng th√°i
      Payment.aggregate([
        { $match: matchCondition },
        {
          $group: {
            _id: "$status",
            count: { $sum: 1 },
            totalAmount: { $sum: "$amount" }
          }
        }
      ]),

      // Th·ªëng k√™ theo ng√†y
      Payment.aggregate([
        { $match: matchCondition },
        {
          $group: {
            _id: {
              year: { $year: "$createdAt" },
              month: { $month: "$createdAt" },
              day: { $dayOfMonth: "$createdAt" }
            },
            count: { $sum: 1 },
            totalAmount: { $sum: "$amount" },
            successCount: {
              $sum: {
                $cond: [{ $eq: ["$status", "success"] }, 1, 0]
              }
            }
          }
        },
        { $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 } }
      ])
    ]);

    return {
      total: totalStats[0] || { totalAmount: 0, totalPayments: 0, avgAmount: 0 },
      byMethod: methodStats,
      byStatus: statusStats,
      daily: dailyStats
    };
  }
}