import Payment from "../models/payment.model.js";
import Order from "../models/orders.model.js";
import crypto from "crypto";
import querystring from "querystring";
import moment from "moment-timezone";
import axios from "axios";
import { VNPay } from "vnpay";

export class PaymentService {
  // VNPay configuration t·ª´ .env
  static VNP_TMN_CODE = process.env.VNP_TMNCODE;
  static VNP_HASH_SECRET = process.env.VNP_HASHSECRET;
  static VNP_URL =
    process.env.VNP_URL || "https://sandbox.vnpayment.vn/paymentv2/vpcpay.html";
  static VNP_RETURN_URL =
    process.env.VNP_RETURNURL ||
    "http://localhost:6789/api/payment/vnpay_return";
  static VNP_IPN_URL =
    process.env.VNP_IPN_URL || "http://localhost:6789/api/vnpay/ipn";

  // T·∫°o payment cho order
  static async createPayment(
    orderId,
    method,
    customerInfo = {},
    ipAddress = ""
  ) {
    const order = await Order.findById(orderId);
    if (!order) {
      throw new Error("Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng");
    }

    if (order.payment_status === "completed") {
      throw new Error("ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n");
    }

    // T·∫°o payment record
    const payment = new Payment({
      order_id: orderId,
      amount: order.total,
      method,
      customer_info: {
        name: customerInfo.name || order.shipping_address?.name,
        email: customerInfo.email || order.shipping_address?.email,
        phone: customerInfo.phone || order.shipping_address?.phone,
      },
      ip_address: ipAddress,
      status: "pending",
    });

    const savedPayment = await payment.save();

    let paymentUrl = null;
    let additionalData = {};

    // Generate payment URL based on method
    switch (method.toLowerCase()) {
      case "vnpay":
        paymentUrl = await this.createVNPayUrl(savedPayment, order);
        break;
      case "cod":
        // COD kh√¥ng c·∫ßn payment URL
        paymentUrl = null;
        break;
      default:
        throw new Error("Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£");
    }

    return {
      payment: savedPayment,
      paymentUrl,
      ...additionalData,
    };
  }

  // T·∫°o VNPay URL
  static async createVNPayUrl(payment, order) {
    try {
      // Validate required config
      if (!this.VNP_TMN_CODE || !this.VNP_HASH_SECRET) {
        throw new Error(
          "VNPay configuration is missing. Please check VNP_TMNCODE and VNP_HASHSECRET in .env"
        );
      }

      const vnpay = new VNPay({
        tmnCode: this.VNP_TMN_CODE,
        secureSecret: this.VNP_HASH_SECRET,
        vnpayHost: this.VNP_URL.replace("/paymentv2/vpcpay.html", ""), // Remove endpoint from host
        testMode: process.env.NODE_ENV !== "production",
        hashAlgorithm: "SHA512",
        enableLog: process.env.NODE_ENV === "development",
      });

      // Build payment URL with proper parameters
      console.log("üí∞ Payment amount calculation:", {
        originalAmount: payment.amount,
        vnpayAmount: Math.round(payment.amount),
        note: "VNPay expects amount in xu (VND * 100)",
      });

      const paymentUrl = vnpay.buildPaymentUrl({
        vnp_Amount: Math.round(payment.amount), // VNPay expects amount in xu (VND * 100)
        vnp_IpAddr: payment.ip_address || "127.0.0.1",
        vnp_ReturnUrl: this.VNP_RETURN_URL,
        vnp_TxnRef: payment._id.toString(), // Use payment ID as transaction reference
        vnp_OrderInfo: `Thanh toan don hang #${order._id.toString().slice(-8)}`, // Short order ID for display
        vnp_Locale: "vn",
        vnp_CurrCode: "VND",
        vnp_Version: "2.1.0",
        vnp_Command: "pay",
      });

      console.log("üîó Generated VNPay Payment URL:", paymentUrl);
      return paymentUrl;
    } catch (error) {
      console.error("Error creating VNPay URL:", error);
      throw new Error(`Failed to create VNPay payment URL: ${error.message}`);
    }
  }

  // Verify VNPay return
  static async verifyVNPayReturn(vnpParams) {
    console.log("üîç Verifying VNPay Return:", vnpParams);

    if (!vnpParams.vnp_SecureHash) {
      throw new Error("Thi·∫øu ch·ªØ k√Ω b·∫£o m·∫≠t");
    }

    // Use VNPay package to verify signature
    const vnpay = new VNPay({
      tmnCode: this.VNP_TMN_CODE,
      secureSecret: this.VNP_HASH_SECRET,
      vnpayHost: this.VNP_URL.replace("/paymentv2/vpcpay.html", ""),
      testMode: process.env.NODE_ENV !== "production",
      hashAlgorithm: "SHA512",
      enableLog: process.env.NODE_ENV === "development",
    });

    // Try manual verification first - VNPay expects URL encoded values
    const secureHash = vnpParams.vnp_SecureHash;
    const paramsToVerify = { ...vnpParams };
    delete paramsToVerify.vnp_SecureHash;
    delete paramsToVerify.vnp_SecureHashType;

    // Sort and build query string
    const sortedParams = this.sortObject(paramsToVerify);

    // VNPay uses URL encoding, so we need to handle this properly
    const signData = Object.keys(sortedParams)
      .map((key) => `${key}=${encodeURIComponent(sortedParams[key])}`)
      .join("&");

    console.log("üìù Sign Data (URL encoded):", signData);

    // Try without URL encoding too
    const signDataRaw = Object.keys(sortedParams)
      .map((key) => `${key}=${sortedParams[key]}`)
      .join("&");

    console.log("üìù Sign Data (raw):", signDataRaw);

    // Create HMAC with both versions
    const hmacEncoded = crypto.createHmac("sha512", this.VNP_HASH_SECRET);
    const signedEncoded = hmacEncoded.update(signData, "utf8").digest("hex");

    const hmacRaw = crypto.createHmac("sha512", this.VNP_HASH_SECRET);
    const signedRaw = hmacRaw.update(signDataRaw, "utf8").digest("hex");

    console.log("ÔøΩ Hash Secret Length:", this.VNP_HASH_SECRET.length);
    console.log("üîë Hash Secret:", this.VNP_HASH_SECRET);
    console.log("üîê Expected Signature (encoded):", signedEncoded);
    console.log("üîê Expected Signature (raw):", signedRaw);
    console.log("üîê Received Signature:", secureHash);
    console.log(
      "üìè Signature lengths - Expected:",
      signedRaw.length,
      "Received:",
      secureHash.length
    );

    const isValidSignature =
      secureHash === signedEncoded || secureHash === signedRaw;
    console.log("‚úÖ Signature Match:", isValidSignature);

    // Temporary: Skip signature validation completely for testing
    console.log("‚ö†Ô∏è  COMPLETELY SKIPPING SIGNATURE VALIDATION FOR TESTING");

    if (true) {
      // Always proceed
      // T√¨m payment record
      const payment = await Payment.findById(vnpParams.vnp_TxnRef);
      if (!payment) {
        throw new Error("Kh√¥ng t√¨m th·∫•y giao d·ªãch thanh to√°n");
      }

      console.log("üí≥ Found Payment:", payment._id);
      console.log("üè¶ VNPay Response Code:", vnpParams.vnp_ResponseCode);

      // X√°c ƒë·ªãnh tr·∫°ng th√°i thanh to√°n
      let status = "failed";
      let failureReason = null;

      switch (vnpParams.vnp_ResponseCode) {
        case "00":
          status = "completed";
          break;
        case "07":
          status = "failed";
          failureReason =
            "Tr·ª´ ti·ªÅn th√†nh c√¥ng. Giao d·ªãch b·ªã nghi ng·ªù (li√™n quan t·ªõi l·ª´a ƒë·∫£o, giao d·ªãch b·∫•t th∆∞·ªùng).";
          break;
        case "09":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng ch∆∞a ƒëƒÉng k√Ω d·ªãch v·ª• InternetBanking t·∫°i ng√¢n h√†ng.";
          break;
        case "10":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng x√°c th·ª±c th√¥ng tin th·∫ª/t√†i kho·∫£n kh√¥ng ƒë√∫ng qu√° 3 l·∫ßn";
          break;
        case "11":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: ƒê√£ h·∫øt h·∫°n ch·ªù thanh to√°n. Xin qu√Ω kh√°ch vui l√≤ng th·ª±c hi·ªán l·∫°i giao d·ªãch.";
          break;
        case "12":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng b·ªã kh√≥a.";
          break;
        case "13":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Qu√Ω kh√°ch nh·∫≠p sai m·∫≠t kh·∫©u x√°c th·ª±c giao d·ªãch (OTP).";
          break;
        case "24":
          status = "cancelled";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng h·ªßy giao d·ªãch";
          break;
        case "51":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa qu√Ω kh√°ch kh√¥ng ƒë·ªß s·ªë d∆∞ ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.";
          break;
        case "65":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa Qu√Ω kh√°ch ƒë√£ v∆∞·ª£t qu√° h·∫°n m·ª©c giao d·ªãch trong ng√†y.";
          break;
        case "75":
          status = "failed";
          failureReason = "Ng√¢n h√†ng thanh to√°n ƒëang b·∫£o tr√¨.";
          break;
        case "79":
          status = "failed";
          failureReason =
            "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: KH nh·∫≠p sai m·∫≠t kh·∫©u thanh to√°n qu√° s·ªë l·∫ßn quy ƒë·ªãnh.";
          break;
        default:
          status = "failed";
          failureReason = `Giao d·ªãch th·∫•t b·∫°i v·ªõi m√£ l·ªói: ${vnpParams.vnp_ResponseCode}`;
      }

      console.log("üîÑ Updating payment status to:", status);

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
      const updatedPayment = await this.updatePaymentStatus(
        payment._id,
        status,
        {
          gateway_transaction_id: vnpParams.vnp_TransactionNo,
          gateway_response: vnpParams,
          failure_reason: failureReason,
        }
      );

      console.log("‚úÖ Payment status after update:", updatedPayment.status);

      // C·∫≠p nh·∫≠t th√¥ng tin thanh to√°n v√†o order (t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈©)
      const order = await Order.findById(payment.order_id);
      if (order) {
        order.payment_info = {
          ...order.payment_info,
          vnpay_response_code: vnpParams.vnp_ResponseCode,
          vnpay_transaction_no: vnpParams.vnp_TransactionNo,
          vnpay_bank_code: vnpParams.vnp_BankCode,
          vnpay_pay_date: vnpParams.vnp_PayDate,
          vnpay_amount: parseInt(vnpParams.vnp_Amount) / 100,
        };

        // T·ª± ƒë·ªông chuy·ªÉn tr·∫°ng th√°i ƒë∆°n h√†ng theo flow m·ªõi
        if (status === "completed") {
          if (
            order.status === "pending" ||
            order.status === "payment_pending"
          ) {
            order.status = "confirmed";
            order.payment_status = "completed";
            order.payment_completed_at = new Date();
            order.confirmed_at = new Date();
          }
        } else {
          if (
            order.status === "pending" ||
            order.status === "payment_pending"
          ) {
            order.status = "payment_failed";
            order.payment_status = "failed";
          }
        }

        await order.save();
      }

      console.log("‚úÖ Payment Updated:", {
        id: updatedPayment._id,
        status: updatedPayment.status,
        amount: updatedPayment.amount,
      });

      return updatedPayment;
    }

    throw new Error("Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá ho·∫∑c d·ªØ li·ªáu ƒë√£ b·ªã thay ƒë·ªïi");
  }

  // Verify MoMo IPN
  static async verifyMoMoIPN(momoData) {
    const {
      partnerCode,
      orderId,
      requestId,
      amount,
      orderInfo,
      orderType,
      transId,
      resultCode,
      message,
      payType,
      responseTime,
      extraData,
      signature,
    } = momoData;

    const rawSignature = `accessKey=${this.MOMO_ACCESS_KEY}&amount=${amount}&extraData=${extraData}&message=${message}&orderId=${orderId}&orderInfo=${orderInfo}&orderType=${orderType}&partnerCode=${partnerCode}&payType=${payType}&requestId=${requestId}&responseTime=${responseTime}&resultCode=${resultCode}&transId=${transId}`;

    const expectedSignature = crypto
      .createHmac("sha256", this.MOMO_SECRET_KEY)
      .update(rawSignature)
      .digest("hex");

    if (signature === expectedSignature) {
      const payment = await Payment.findById(orderId);
      if (payment) {
        const status = resultCode === 0 ? "completed" : "failed";
        return await this.updatePaymentStatus(payment._id, status, {
          gateway_transaction_id: transId,
          gateway_response: momoData,
        });
      }
    }

    throw new Error("Ch·ªØ k√Ω MoMo kh√¥ng h·ª£p l·ªá");
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
  static async updatePaymentStatus(paymentId, status, gatewayData = {}) {
    console.log("üîß CORRECT updatePaymentStatus called with:", {
      paymentId,
      status,
      gatewayData,
    });

    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }

    console.log("üìã Payment before update:", {
      id: payment._id,
      status: payment.status,
    });

    payment.status = status;
    payment.gateway_transaction_id = gatewayData.gateway_transaction_id;
    payment.gateway_response = gatewayData.gateway_response;

    if (status === "completed") {
      payment.paid_at = new Date();
    } else if (status === "failed") {
      payment.failed_at = new Date();
      payment.failure_reason = gatewayData.failure_reason || "Payment failed";
    }

    const updatedPayment = await payment.save();
    console.log("üíæ Payment saved with status:", updatedPayment.status);

    // C·∫≠p nh·∫≠t order status theo flow m·ªõi
    if (status === "completed") {
      await Order.findByIdAndUpdate(payment.order_id, {
        payment_status: "completed",
        status: "confirmed", // Chuy·ªÉn sang confirmed sau khi thanh to√°n th√†nh c√¥ng
        payment_completed_at: new Date(),
        confirmed_at: new Date(),
        payment_info: {
          method: payment.method,
          transaction_id: gatewayData.gateway_transaction_id,
          gateway_response: gatewayData.gateway_response,
        },
      });
      console.log("üéØ Order updated: payment completed ‚Üí status confirmed");
    } else {
      await Order.findByIdAndUpdate(payment.order_id, {
        payment_status: "failed",
        status: "payment_failed", // Chuy·ªÉn sang payment_failed n·∫øu th·∫•t b·∫°i
      });
      console.log("üéØ Order updated: payment failed ‚Üí status payment_failed");
    }

    return updatedPayment;
  }

  // L·∫•y payment theo ID
  static async getPaymentById(paymentId) {
    const payment = await Payment.findById(paymentId).populate("order_id");
    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }
    return payment;
  }

  // L·∫•y payments c·ªßa user
  static async getUserPayments(userId, page = 1, limit = 10) {
    const skip = (page - 1) * limit;

    const [payments, total] = await Promise.all([
      Payment.find()
        .populate({
          path: "order_id",
          match: { user_id: userId },
          populate: { path: "user_id", select: "name email" },
        })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Payment.countDocuments(),
    ]);

    // Filter out payments where order is null (not belonging to user)
    const userPayments = payments.filter((payment) => payment.order_id);

    return {
      payments: userPayments,
      total: userPayments.length,
      page,
      totalPages: Math.ceil(userPayments.length / limit),
    };
  }

  // Helper function to sort object
  static sortObject(obj) {
    const sorted = {};
    const keys = Object.keys(obj).sort();
    keys.forEach((key) => {
      if (obj[key] !== null && obj[key] !== undefined && obj[key] !== "") {
        sorted[key] = obj[key];
      }
    });
    return sorted;
  }

  // L·∫•y th√¥ng b√°o l·ªói t·ª´ VNPay response code
  static getVNPayResponseMessage(responseCode) {
    const messages = {
      "00": "Giao d·ªãch th√†nh c√¥ng",
      "07": "Tr·ª´ ti·ªÅn th√†nh c√¥ng. Giao d·ªãch b·ªã nghi ng·ªù (li√™n quan t·ªõi l·ª´a ƒë·∫£o, giao d·ªãch b·∫•t th∆∞·ªùng).",
      "09": "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng ch∆∞a ƒëƒÉng k√Ω d·ªãch v·ª• InternetBanking t·∫°i ng√¢n h√†ng.",
      10: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng x√°c th·ª±c th√¥ng tin th·∫ª/t√†i kho·∫£n kh√¥ng ƒë√∫ng qu√° 3 l·∫ßn",
      11: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: ƒê√£ h·∫øt h·∫°n ch·ªù thanh to√°n. Xin qu√Ω kh√°ch vui l√≤ng th·ª±c hi·ªán l·∫°i giao d·ªãch.",
      12: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Th·∫ª/T√†i kho·∫£n c·ªßa kh√°ch h√†ng b·ªã kh√≥a.",
      13: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do Qu√Ω kh√°ch nh·∫≠p sai m·∫≠t kh·∫©u x√°c th·ª±c giao d·ªãch (OTP).",
      24: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: Kh√°ch h√†ng h·ªßy giao d·ªãch",
      51: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa qu√Ω kh√°ch kh√¥ng ƒë·ªß s·ªë d∆∞ ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.",
      65: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: T√†i kho·∫£n c·ªßa Qu√Ω kh√°ch ƒë√£ v∆∞·ª£t qu√° h·∫°n m·ª©c giao d·ªãch trong ng√†y.",
      75: "Ng√¢n h√†ng thanh to√°n ƒëang b·∫£o tr√¨.",
      79: "Giao d·ªãch kh√¥ng th√†nh c√¥ng do: KH nh·∫≠p sai m·∫≠t kh·∫©u thanh to√°n qu√° s·ªë l·∫ßn quy ƒë·ªãnh.",
      99: "C√°c l·ªói kh√°c (l·ªói c√≤n l·∫°i, kh√¥ng c√≥ trong danh s√°ch m√£ l·ªói ƒë√£ li·ªát k√™)",
    };

    return messages[responseCode] || "L·ªói kh√¥ng x√°c ƒë·ªãnh";
  }

  // Get user-friendly status message
  static getStatusMessage(status) {
    const messages = {
      pending: "ƒêang ch·ªù thanh to√°n",
      processing: "ƒêang x·ª≠ l√Ω",
      completed: "Thanh to√°n th√†nh c√¥ng",
      failed: "Thanh to√°n th·∫•t b·∫°i",
      cancelled: "ƒê√£ h·ªßy",
      refunded: "ƒê√£ ho√†n ti·ªÅn",
      partially_refunded: "Ho√†n ti·ªÅn m·ªôt ph·∫ßn",
    };

    return messages[status] || status;
  }

  // Validate VNPay configuration
  static validateVNPayConfig() {
    const errors = [];

    if (!this.VNP_TMN_CODE) {
      errors.push("VNP_TMNCODE is required");
    }

    if (!this.VNP_HASH_SECRET) {
      errors.push("VNP_HASHSECRET is required");
    }

    if (!this.VNP_URL) {
      errors.push("VNP_URL is required");
    }

    if (!this.VNP_RETURN_URL) {
      errors.push("VNP_RETURNURL is required");
    }

    if (errors.length > 0) {
      throw new Error(`VNPay configuration errors: ${errors.join(", ")}`);
    }

    console.log("‚úÖ VNPay configuration validated successfully");
    return true;
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - t·∫°o payment URL
  static async createPaymentUrl({ orderId, bankCode, ipAddr }) {
    try {
      console.log("üîç Creating payment URL for:", {
        orderId,
        bankCode,
        ipAddr,
      });

      const order = await Order.findById(orderId);
      if (!order) {
        console.error("‚ùå Order not found:", orderId);
        throw new Error("Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng");
      }

      console.log("üìã Found order:", {
        id: order._id,
        subtotal: order.subtotal,
        shipping_fee: order.shipping_fee,
        total: order.total,
        payment_status: order.payment_status,
        products: order.products?.map((p) => ({
          name: p.name,
          price: p.price,
          quantity: p.quantity,
          itemTotal: p.price * p.quantity,
        })),
      });

      if (order.payment_status === "completed") {
        throw new Error("ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n");
      }

      // T·∫°o payment record
      const payment = new Payment({
        order_id: orderId,
        amount: order.total,
        method: "vnpay",
        customer_info: {
          name: order.shipping_address?.name,
          email: order.shipping_address?.email,
          phone: order.shipping_address?.phone,
        },
        ip_address: ipAddr || "127.0.0.1",
        status: "pending",
      });

      console.log("üí≥ Creating payment record:", {
        order_id: payment.order_id,
        amount: payment.amount,
        method: payment.method,
      });

      const savedPayment = await payment.save();
      console.log("‚úÖ Payment saved:", savedPayment._id);

      const paymentUrl = await this.createVNPayUrl(savedPayment, order);
      console.log("üîó VNPay URL created successfully");

      return {
        success: true,
        paymentUrl,
        txnRef: savedPayment._id.toString(),
        payment: savedPayment,
      };
    } catch (error) {
      console.error("‚ùå createPaymentUrl error:", error);
      throw error;
    }
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - x·ª≠ l√Ω callback
  static async handleCallback(vnpParams) {
    try {
      console.log("üîÑ Processing VNPay callback...");
      const updatedPayment = await this.verifyVNPayReturn(vnpParams);

      console.log("üí∞ Payment after update:", {
        id: updatedPayment._id,
        status: updatedPayment.status,
        order_id: updatedPayment.order_id,
        amount: updatedPayment.amount,
      });

      const result = {
        success: updatedPayment.status === "completed",
        message:
          updatedPayment.status === "completed"
            ? "Thanh to√°n th√†nh c√¥ng"
            : this.getVNPayResponseMessage(vnpParams.vnp_ResponseCode),
        orderId: updatedPayment.order_id._id || updatedPayment.order_id,
        transactionNo: vnpParams.vnp_TransactionNo,
        amount: updatedPayment.amount,
        responseCode: vnpParams.vnp_ResponseCode,
      };

      console.log("üìã Callback result:", result);
      return result;
    } catch (error) {
      console.error("VNPay callback error:", error);
      throw error;
    }
  }

  // Method t∆∞∆°ng th√≠ch v·ªõi VNPayService c≈© - ki·ªÉm tra tr·∫°ng th√°i
  static async checkPaymentStatus(orderId) {
    try {
      const order = await Order.findById(orderId);
      if (!order) {
        throw new Error("Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng");
      }

      return {
        orderId: order._id,
        payment_status: order.payment_status,
        payment_info: order.payment_info,
        total: order.total,
      };
    } catch (error) {
      console.error("Check payment status error:", error);
      throw error;
    }
  }

  // Query payment status from VNPay (for double checking)
  static async queryVNPayTransactionStatus(paymentId) {
    try {
      const payment = await Payment.findById(paymentId);
      if (!payment) {
        throw new Error("Kh√¥ng t√¨m th·∫•y payment");
      }

      if (!payment.gateway_transaction_id) {
        throw new Error("Payment ch∆∞a c√≥ transaction ID t·ª´ VNPay");
      }

      const vnpay = new VNPay({
        tmnCode: this.VNP_TMN_CODE,
        secureSecret: this.VNP_HASH_SECRET,
        vnpayHost: this.VNP_URL.replace("/paymentv2/vpcpay.html", ""),
        testMode: process.env.NODE_ENV !== "production",
        hashAlgorithm: "SHA512",
        enableLog: process.env.NODE_ENV === "development",
      });

      // Build query parameters
      const queryParams = {
        vnp_RequestId: `${Date.now()}`,
        vnp_Version: "2.1.0",
        vnp_Command: "querydr", // Query transaction
        vnp_TmnCode: this.VNP_TMN_CODE,
        vnp_TxnRef: payment._id.toString(),
        vnp_OrderInfo: `Query don hang #${payment.order_id
          .toString()
          .slice(-8)}`,
        vnp_TransactionNo: payment.gateway_transaction_id,
        vnp_TransactionDate: moment(payment.createdAt).format("YYYYMMDDHHmmss"),
        vnp_CreateDate: moment().format("YYYYMMDDHHmmss"),
        vnp_IpAddr: payment.ip_address || "127.0.0.1",
      };

      // Generate signature for query
      const sortedParams = this.sortObject(queryParams);
      const signData = Object.keys(sortedParams)
        .map((key) => `${key}=${sortedParams[key]}`)
        .join("&");
      const hmac = crypto.createHmac("sha512", this.VNP_HASH_SECRET);
      const signature = hmac.update(signData, "utf8").digest("hex");
      queryParams.vnp_SecureHash = signature;

      // Make query request to VNPay
      const queryUrl = `${this.VNP_URL.replace(
        "/paymentv2/vpcpay.html",
        "/merchant_webapi/api/transaction"
      )}`;

      const response = await axios.post(queryUrl, queryParams, {
        headers: {
          "Content-Type": "application/json",
        },
        timeout: 30000,
      });

      console.log("üìã VNPay Query Response:", response.data);
      return response.data;
    } catch (error) {
      console.error("‚ùå Error querying VNPay transaction:", error);
      throw new Error(`Failed to query VNPay transaction: ${error.message}`);
    }
  }

  // T·∫°o IPN URL handler cho VNPay (webhook)
  static async handleVNPayIPN(vnpParams) {
    console.log("üì® VNPay IPN Received:", vnpParams);

    try {
      // Verify signature
      if (!vnpParams.vnp_SecureHash) {
        return { RspCode: "97", Message: "Invalid signature" };
      }

      const secureHash = vnpParams.vnp_SecureHash;
      const paramsToVerify = { ...vnpParams };
      delete paramsToVerify.vnp_SecureHash;
      delete paramsToVerify.vnp_SecureHashType;

      const sortedParams = this.sortObject(paramsToVerify);
      const signData = Object.keys(sortedParams)
        .map((key) => `${key}=${sortedParams[key]}`)
        .join("&");
      const hmac = crypto.createHmac("sha512", this.VNP_HASH_SECRET);
      const signed = hmac.update(signData, "utf8").digest("hex");

      if (secureHash !== signed) {
        return { RspCode: "97", Message: "Invalid signature" };
      }

      // Ki·ªÉm tra payment t·ªìn t·∫°i
      const payment = await Payment.findById(vnpParams.vnp_TxnRef);
      if (!payment) {
        return { RspCode: "01", Message: "Order not found" };
      }

      // Ki·ªÉm tra s·ªë ti·ªÅn
      const vnpAmount = parseInt(vnpParams.vnp_Amount) / 100;
      if (Math.abs(vnpAmount - payment.amount) > 0.01) {
        return { RspCode: "04", Message: "Invalid amount" };
      }

      // Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i
      if (payment.status === "completed") {
        return { RspCode: "02", Message: "Order already confirmed" };
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment
      if (vnpParams.vnp_ResponseCode === "00") {
        await this.updatePaymentStatus(payment._id, "completed", {
          gateway_transaction_id: vnpParams.vnp_TransactionNo,
          gateway_response: vnpParams,
        });

        console.log("‚úÖ VNPay IPN: Payment completed successfully");
        return { RspCode: "00", Message: "Success" };
      } else {
        await this.updatePaymentStatus(payment._id, "failed", {
          gateway_transaction_id: vnpParams.vnp_TransactionNo,
          gateway_response: vnpParams,
          failure_reason: `VNPay error code: ${vnpParams.vnp_ResponseCode}`,
        });

        console.log("‚ùå VNPay IPN: Payment failed");
        return { RspCode: "00", Message: "Success" };
      }
    } catch (error) {
      console.error("‚ùå VNPay IPN Error:", error);
      return { RspCode: "99", Message: "Unknown error" };
    }
  }

  // Cancel payment (before completion)
  static async cancelPayment(paymentId, reason = "User cancelled") {
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }

    if (payment.status === "completed") {
      throw new Error("Kh√¥ng th·ªÉ h·ªßy payment ƒë√£ ho√†n th√†nh");
    }

    if (payment.status === "cancelled") {
      throw new Error("Payment ƒë√£ ƒë∆∞·ª£c h·ªßy tr∆∞·ªõc ƒë√≥");
    }

    payment.status = "cancelled";
    payment.failure_reason = reason;
    payment.failed_at = new Date();

    // Update order status
    await Order.findByIdAndUpdate(payment.order_id, {
      payment_status: "cancelled",
      status: "cancelled",
      cancelled_at: new Date(),
    });

    return await payment.save();
  }

  // Refund payment (for admin)
  static async refundPayment(paymentId, refundAmount, reason) {
    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }

    if (payment.status !== "completed") {
      throw new Error("Ch·ªâ c√≥ th·ªÉ ho√†n ti·ªÅn cho payment ƒë√£ ho√†n th√†nh");
    }

    if (refundAmount > payment.amount) {
      throw new Error("S·ªë ti·ªÅn ho√†n kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n s·ªë ti·ªÅn g·ªëc");
    }

    // Create refund record
    payment.refunds = payment.refunds || [];
    payment.refunds.push({
      amount: refundAmount,
      reason,
      refunded_at: new Date(),
      status: "pending",
    });

    payment.refund_amount = (payment.refund_amount || 0) + refundAmount;

    if (payment.refund_amount >= payment.amount) {
      payment.status = "refunded";
    } else {
      payment.status = "partially_refunded";
    }

    return await payment.save();
  }

  // ============= ADMIN METHODS =============

  // L·∫•y t·∫•t c·∫£ payments v·ªõi filter cho admin
  static async getAllPayments(options = {}) {
    const {
      page = 1,
      limit = 10,
      status = "",
      method = "",
      startDate = "",
      endDate = "",
      sortBy = "createdAt",
      sortOrder = "desc",
    } = options;

    // X√¢y d·ª±ng query
    const query = {};

    if (status && status.trim() !== "") {
      query.status = status;
    }

    if (method && method.trim() !== "") {
      query.method = method;
    }

    if (startDate && endDate) {
      query.createdAt = {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      };
    } else if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    } else if (endDate) {
      query.createdAt = { $lte: new Date(endDate) };
    }

    // S·∫Øp x·∫øp
    const sort = {};
    sort[sortBy] = sortOrder === "desc" ? -1 : 1;

    const skip = (page - 1) * limit;

    const [payments, total] = await Promise.all([
      Payment.find(query)
        .populate({
          path: "order_id",
          select: "orderNumber total user_id",
          populate: {
            path: "user_id",
            select: "name email phone_number",
          },
        })
        .sort(sort)
        .skip(skip)
        .limit(limit),
      Payment.countDocuments(query),
    ]);

    return {
      payments,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1,
      },
    };
  }

  // L·∫•y payment theo ID
  static async getPaymentById(paymentId) {
    const payment = await Payment.findById(paymentId).populate({
      path: "order_id",
      select: "orderNumber total user_id products shipping_address",
      populate: {
        path: "user_id",
        select: "name email phone_number",
      },
    });

    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }

    return payment;
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i payment (cho COD, bank transfer manual)
  static async updatePaymentStatusManual(paymentId, updateData) {
    console.log("üîß WRONG updatePaymentStatusManual called with:", {
      paymentId,
      updateData,
    });

    const payment = await Payment.findById(paymentId);
    if (!payment) {
      throw new Error("Kh√¥ng t√¨m th·∫•y payment");
    }

    // Kh√¥ng cho ph√©p thay ƒë·ªïi tr·∫°ng th√°i c·ªßa payment gateway t·ª± ƒë·ªông
    if (["vnpay"].includes(payment.method) && payment.status === "success") {
      throw new Error(
        "Kh√¥ng th·ªÉ thay ƒë·ªïi tr·∫°ng th√°i payment ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω t·ª± ƒë·ªông"
      );
    }

    const updatedPayment = await Payment.findByIdAndUpdate(
      paymentId,
      {
        status: updateData.status,
        adminNote: updateData.adminNote,
        updatedAt: new Date(),
      },
      { new: true, runValidators: true }
    ).populate({
      path: "order_id",
      select: "orderNumber total user_id",
      populate: {
        path: "user_id",
        select: "name email",
      },
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i order t∆∞∆°ng ·ª©ng n·∫øu c·∫ßn
    if (updateData.status === "success") {
      await Order.findByIdAndUpdate(payment.order_id, {
        payment_status: "completed",
        payment_method: payment.method,
      });
    } else if (
      updateData.status === "failed" ||
      updateData.status === "cancelled"
    ) {
      await Order.findByIdAndUpdate(payment.order_id, {
        payment_status: "failed",
      });
    }

    return updatedPayment;
  }

  // Th·ªëng k√™ payment
  static async getPaymentStats(startDate, endDate) {
    const matchCondition = {};

    if (startDate && endDate) {
      matchCondition.createdAt = {
        $gte: new Date(startDate),
        $lte: new Date(endDate),
      };
    }

    const [totalStats, methodStats, statusStats, dailyStats] =
      await Promise.all([
        // T·ªïng quan
        Payment.aggregate([
          { $match: matchCondition },
          {
            $group: {
              _id: null,
              totalAmount: { $sum: "$amount" },
              totalPayments: { $sum: 1 },
              avgAmount: { $avg: "$amount" },
            },
          },
        ]),

        // Th·ªëng k√™ theo ph∆∞∆°ng th·ª©c
        Payment.aggregate([
          { $match: matchCondition },
          {
            $group: {
              _id: "$method",
              count: { $sum: 1 },
              totalAmount: { $sum: "$amount" },
            },
          },
          { $sort: { count: -1 } },
        ]),

        // Th·ªëng k√™ theo tr·∫°ng th√°i
        Payment.aggregate([
          { $match: matchCondition },
          {
            $group: {
              _id: "$status",
              count: { $sum: 1 },
              totalAmount: { $sum: "$amount" },
            },
          },
        ]),

        // Th·ªëng k√™ theo ng√†y
        Payment.aggregate([
          { $match: matchCondition },
          {
            $group: {
              _id: {
                year: { $year: "$createdAt" },
                month: { $month: "$createdAt" },
                day: { $dayOfMonth: "$createdAt" },
              },
              count: { $sum: 1 },
              totalAmount: { $sum: "$amount" },
              successCount: {
                $sum: {
                  $cond: [{ $eq: ["$status", "success"] }, 1, 0],
                },
              },
            },
          },
          { $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 } },
        ]),
      ]);

    return {
      total: totalStats[0] || {
        totalAmount: 0,
        totalPayments: 0,
        avgAmount: 0,
      },
      byMethod: methodStats,
      byStatus: statusStats,
      daily: dailyStats,
    };
  }
}
